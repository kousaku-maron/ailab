# UI コンポーネント設計

## 基本方針

コンポーネントを実装する際は、以下の「コンポーネント集約アプローチ」に従ってください。このアプローチは、ファイル数を最小限に抑え、関連するコードを同じファイルに配置することで、AI 駆動開発に最適化されています。

## コンポーネント組織化の原則

### 1. 機能ベースのファイル構成

コンポーネントは「タイプ別」ではなく「機能別」にグループ化してください。特定の機能を実装するために連携する関連コンポーネントは、同じファイルに配置します。

**良い例:**

```
app/components/interview.tsx  // InterviewModeやChatInterfaceなど関連コンポーネントを含む
```

**避けるべき例:**

```
app/components/interview/InterviewMode.tsx
app/components/interview/ChatInterface.tsx
```

### 2. 新規ファイル作成の基準

以下の場合にのみ新しいファイルを作成してください：

- コンポーネントまたはコンポーネントグループが明確に独立した機能を実装している
- ファイルが大きくなりすぎる（300〜400 行以上）場合
- コンポーネントが複数の無関係な機能で使用される場合

### 3. 共有コンポーネントの扱い

真に再利用可能なコンポーネントは `shared.tsx` などの共有ファイルに配置してください。以下の条件を満たすコンポーネントが共有ファイルに適しています：

- 複数の機能コンポーネントで使用される
- 明確で安定した API を持つ
- 特定の機能に依存するロジックを含まない

### 4. ファイル内のコンポーネント構造

1 つのファイルに複数のコンポーネントが存在する場合：

1. 小さなヘルパーコンポーネントを最初に定義
2. メインとなるエクスポートされるコンポーネントを最後に定義
3. 主要なコンポーネントを区切るためにセクションコメントを使用
4. ファイル外で使用する必要があるコンポーネントのみをエクスポート

```tsx
// ヘルパーコンポーネント
function HelperComponent1() { ... }
function HelperComponent2() { ... }

// メインコンポーネント
export function MainComponent() {
  // HelperComponent1とHelperComponent2を使用
}
```

## コードスタイルガイドライン

### 1. Props インターフェース

- Props インターフェースは使用するコンポーネントの近くに定義
- 説明的な名前を使用（単なる`Props`ではなく`ButtonProps`など）
- 共有インターフェースはファイルの先頭に配置

```tsx
interface NoteItemProps {
  note: Note;
  isSelected: boolean;
  onClick: (id: string) => void;
}

function NoteItem({ note, isSelected, onClick }: NoteItemProps) {
  // ...
}
```

### 2. コンポーネント実装

- フックを使用した関数コンポーネントを使用
- コンポーネントは単一の責任に集中
- 複雑なロジックは必要に応じてカスタムフックに抽出
- コンポーネントが使用するものを明確にするために props の分割代入を使用

### 3. 状態管理

- 状態はできるだけローカルに保持
- 必要な場合のみ状態を持ち上げる
- コンテキストは慎重に、真にグローバルな状態にのみ使用
- 複雑な状態ロジックにはカスタムフックの使用を検討

## AI 駆動開発に適した実践

コードベースを AI 駆動開発に適したものにするために：

### 1. 明確なコンポーネント境界

- コンポーネントの責任を明確かつ集中させる
- 説明的な変数名と関数名を使用
- 複雑なロジックやビジネスルールにはコメントを追加

### 2. 関連コードの共存

- 関連するコンポーネントを同じファイルに保持
- ヘルパー関数は使用される場所の近くに配置
- 関連する状態とエフェクトをグループ化

### 3. 一貫したパターン

- 類似機能には一貫したパターンを使用
- 類似コンポーネントには同じ構造を使用
- 共通タスク（フォーム、リストなど）にはパターンを再利用

### 4. ドキュメント

- 複雑なコンポーネントには JSDoc コメントを追加
- 自明でない props や動作についてドキュメント化
- 再利用可能なコンポーネントには例を含める

## 新機能の実装例

新機能を実装する際は、以下の手順に従ってください：

1. **機能の範囲を特定**: 新しいスタンドアロン機能か、既存機能の拡張かを判断
2. **適切なファイルを選択**: スタンドアロン機能には新しいファイル、拡張には既存ファイルを使用
3. **コンポーネントの実装**: ヘルパーコンポーネントから始め、メインコンポーネントを構築
4. **共有コンポーネントの抽出**: 他の場所で再利用できるコンポーネントがあれば、`shared.tsx`に移動
5. **インポートの更新**: 新しいコンポーネントを使用する他のファイルのインポートを更新

### 実装パターン例

```tsx
// app/components/feature-name.tsx

// 依存関係のインポート
import { useState } from "react";
import type { RequiredTypes } from "~/types";
import { SharedComponents } from "./shared";

// ヘルパーコンポーネントのインターフェースと実装
interface HelperComponentProps {
  // Propsの定義
}

function HelperComponent({ prop1, prop2 }: HelperComponentProps) {
  // 実装
}

// メインコンポーネントのインターフェースと実装
interface MainFeatureProps {
  // Propsの定義
}

export function MainFeature({ mainProp1, mainProp2 }: MainFeatureProps) {
  // 状態管理
  const [state, setState] = useState(initialValue);

  // イベントハンドラ
  const handleEvent = () => {
    // 実装
  };

  // レンダリング
  return (
    <div>
      <HelperComponent prop1={value} prop2={value} />
      {/* 残りの実装 */}
    </div>
  );
}
```

## 既存コンポーネントの修正時

1. 機能内でのコンポーネントの役割を理解する
2. 既存のパターンと命名規則を維持する
3. 関連する機能を一緒に保持する
4. 同じファイル内の影響を受けるコンポーネントを更新する
5. 共有コンポーネントへの影響を考慮する
